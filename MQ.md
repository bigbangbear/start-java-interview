### 1. MQ 是什么？有什么优点

MQ：消息队列，

优点：解耦、削峰、异步

缺点：系统的复杂性、需要考虑高可用、数据丢失、数据重发、有序发送等问题

### 2. 常用消息队列比较

| 对比     | Active MQ | Rabbit MQ | Rocket MQ | Kafka      |
| -------- | --------- | --------- | --------- | ---------- |
| 吞吐量   | 1W        | 1W        | 10W       | 10W        |
| 高可用   | 主从      | 主从      | 分布式    | 分布式     |
| 时延     | 1ms       | 1ns       | 1ms       | 1ms        |
| 维护     | Java      | Erlang    | java      | java/scala |
| 顺序消息 | 不支持    | 不支持    | 支持      | 支持       |
| 持久化   | 少量堆积  | 少量堆积  | 大量堆积  | 大量堆积   |

### 3. 消息队列顺序问题 [参考](https://sa.sogou.com/sgsearch/sgs_tc_news.php?req=nxiYB_RqrtR_RCBzn7Mur64FYacCUx0frbgmBhIDEUQ=&user_type=1)

> 生产者生产的消息需要被消费者按照顺序有序消费

Kafka：在相同 Patition 上可以保证消息消费的有序性，根据规则将消息转发到相同 Broker 的 Patition 上，从而保证消息消费的有序性。

> 消费者多个线程并发处理导致消息消费乱序

在消费者中维护多个内存队列，通过将 Key Hash 到指定的队列上，让相同的线程处理对应队列的数据，从而避免乱序消费问题

### 4. 消息不丢失

通过生产者端，确保消息发送成功，发送失败后通过重试机制重发

Broker 通过副本机制进行备份，防止消息的丢失

### 4. 消息的重复发送问题

原因：消费者消费消息后未提交 offset，导致重复消费。

通过配置 broker 的 ack = all，确保所有的副本都收到消息，保证消息的不丢失

消费者端通过去重机制保证消息的不重复消费，例如通过 ID 标识消息是否消费

配置消费者手动提交消息 offset

### 5. 消息积压怎么处理 [参考](https://juejin.cn/post/6844903849107406856)

1. 新增新的 Topic，配置 partion 数量进行扩容 
2. 修改旧的消费者，收到消息后转发到新的 Topic
3. 新的 Consumer 进行消费

